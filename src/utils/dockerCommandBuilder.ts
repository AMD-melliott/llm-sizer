import type { ContainerConfig } from '../types';

export interface DockerCommandOptions {
  includeComments?: boolean;
  includeManagementCommands?: boolean;
}

export function generateDockerRunCommand(
  config: ContainerConfig,
  options: DockerCommandOptions = {}
): string {
  const {
    includeComments = true,
    includeManagementCommands = true,
  } = options;
  
  const lines: string[] = [];
  
  // Header
  if (includeComments) {
    lines.push('#!/bin/bash');
    lines.push('# Generated by AMD LLM Sizer - Docker Configuration Generator');
    lines.push(`# Generated: ${new Date().toISOString()}`);
    lines.push('#');
    lines.push(`# Model: ${config.model.name}`);
    lines.push(`# Parameters: ${config.model.parameters}B`);
    lines.push(`# GPUs: ${config.gpuCount}x ${config.gpus[0]?.name || 'GPU'}`);
    lines.push(`# Estimated VRAM: ${config.memoryUsage.estimated.toFixed(1)}GB / ${config.memoryUsage.available.toFixed(1)}GB (${config.memoryUsage.percentage.toFixed(1)}%)`);
    lines.push('#');
    lines.push('# Prerequisites:');
    
    if (config.useContainerToolkit) {
      lines.push('# - AMD Container Toolkit installed');
      lines.push('#   https://rocm.docs.amd.com/projects/container-toolkit');
    } else {
      lines.push('# - Docker with ROCm support');
      lines.push('# - ROCm drivers installed on host');
    }
    
    lines.push('# - Docker version 19.03 or higher');
    
    if (config.environment.some(env => env.sensitive)) {
      lines.push('# - Set environment variables for sensitive values (e.g., HF_TOKEN)');
    }
    
    lines.push('#');
    lines.push('# IMPORTANT: Make this script executable with: chmod +x run-inference.sh');
    lines.push('#');
    lines.push('');
    
    // Bash strict mode
    lines.push('# Enable strict error handling');
    lines.push('set -euo pipefail');
    lines.push('');
    
    // Environment variable checks
    const requiredEnvVars = config.environment.filter(env => env.sensitive && env.value.startsWith('${'));
    if (requiredEnvVars.length > 0) {
      lines.push('# Verify required environment variables');
      requiredEnvVars.forEach(env => {
        const varName = env.value.replace(/[${}]/g, '');
        lines.push(`if [ -z "\${${varName}:-}" ]; then`);
        lines.push(`  echo "Error: ${varName} environment variable is not set" >&2`);
        lines.push(`  echo "Please set it before running this script: export ${varName}=your-value" >&2`);
        lines.push('  exit 1');
        lines.push('fi');
      });
      lines.push('');
    }
    
    // Preflight checks
    lines.push('# Preflight checks');
    lines.push('if ! command -v docker &> /dev/null; then');
    lines.push('  echo "Error: Docker is not installed or not in PATH" >&2');
    lines.push('  exit 1');
    lines.push('fi');
    lines.push('');
    
    if (config.useContainerToolkit) {
      lines.push('# Check for AMD Container Toolkit');
      lines.push('if ! docker info 2>/dev/null | grep -q "Runtimes.*amd"; then');
      lines.push('  echo "Warning: AMD runtime not found. Container Toolkit may not be installed." >&2');
      lines.push('  echo "See: https://rocm.docs.amd.com/projects/container-toolkit" >&2');
      lines.push('fi');
      lines.push('');
    }
    
    lines.push('echo "Starting vLLM inference container..."');
    lines.push('');
  }
  
  // Main command
  lines.push('docker run -d \\');
  lines.push(`  --name ${config.containerName} \\`);
  
  // Runtime
  if (config.useContainerToolkit) {
    lines.push('  --runtime=amd \\');
  } else {
    // Fallback method: Direct device access
    lines.push('  --device=/dev/kfd \\');
    lines.push('  --device=/dev/dri \\');
    lines.push('  --group-add video \\');
  }

  // Environment variables (GPU devices are already in config.environment)
  config.environment.forEach(env => {
    if (includeComments && env.description) {
      lines.push(`  # ${env.description}`);
    }
    lines.push(`  -e ${env.key}=${env.value} \\`);
  });
  
  // Resources
  lines.push(`  --shm-size=${config.shmSize} \\`);
  
  if (config.resourceLimits?.memoryLimit) {
    lines.push(`  --memory=${config.resourceLimits.memoryLimit} \\`);
  }
  
  if (config.resourceLimits?.cpuLimit) {
    lines.push(`  --cpus=${config.resourceLimits.cpuLimit} \\`);
  }
  
  // Network
  if (config.useHostNetwork) {
    lines.push('  --network=host \\');
  } else {
    // Port mappings
    config.ports.forEach(port => {
      if (includeComments && port.description) {
        lines.push(`  # ${port.description}`);
      }
      const protocol = port.protocol ? `/${port.protocol}` : '';
      lines.push(`  -p ${port.host}:${port.container}${protocol} \\`);
    });
  }
  
  // Volumes
  config.volumes.forEach(vol => {
    if (includeComments && vol.description) {
      lines.push(`  # ${vol.description}`);
    }
    const ro = vol.readOnly ? ':ro' : '';
    lines.push(`  -v ${vol.hostPath}:${vol.containerPath}${ro} \\`);
  });
  
  // Restart policy
  lines.push('  --restart unless-stopped \\');
  
  // Image
  lines.push(`  ${config.image.fullImage} \\`);
  
  // Engine parameters
  config.engineParams.forEach((param, i) => {
    const isLast = i === config.engineParams.length - 1;
    const suffix = isLast ? '' : ' \\';
    
    if (typeof param.value === 'boolean') {
      if (param.value) {
        lines.push(`  ${param.flag}${suffix}`);
      }
    } else {
      lines.push(`  ${param.flag} ${param.value}${suffix}`);
    }
  });
  
  // Success message and management commands
  if (includeComments && includeManagementCommands) {
    lines.push('');
    lines.push('# Check if container started successfully');
    lines.push('if [ $? -eq 0 ]; then');
    lines.push(`  echo "✓ Container '${config.containerName}' started successfully"`);
    lines.push('  echo ""');
    lines.push(`  echo "API will be available at: http://localhost:${config.ports[0]?.host || 8000}"`);
    lines.push('  echo ""');
    lines.push('  echo "Container management commands:"');
    lines.push(`  echo "  View logs:    docker logs -f ${config.containerName}"`);
    lines.push(`  echo "  Stop:         docker stop ${config.containerName}"`);
    lines.push(`  echo "  Restart:      docker restart ${config.containerName}"`);
    lines.push(`  echo "  Remove:       docker rm ${config.containerName}"`);
    lines.push(`  echo "  Shell access: docker exec -it ${config.containerName} bash"`);
    lines.push('else');
    lines.push('  echo "✗ Failed to start container" >&2');
    lines.push('  exit 1');
    lines.push('fi');
  }
  
  return lines.join('\n');
}

export function generateShellScript(config: ContainerConfig): string {
  return generateDockerRunCommand(config, {
    includeComments: true,
    includeManagementCommands: true,
  });
}

export function generateDockerCommandOnly(config: ContainerConfig): string {
  return generateDockerRunCommand(config, {
    includeComments: false,
    includeManagementCommands: false,
  });
}

// Helper to validate generated command
export function validateDockerCommand(command: string): {
  valid: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  
  // Check for security anti-patterns
  if (command.includes('--privileged')) {
    issues.push('Command contains --privileged flag (security risk)');
  }
  
  if (command.includes('--cap-add=SYS_ADMIN')) {
    issues.push('Command contains CAP_SYS_ADMIN capability (security risk)');
  }
  
  if (command.includes('--security-opt seccomp=unconfined')) {
    issues.push('Command disables seccomp (security risk)');
  }
  
  // Check for hardcoded secrets
  const tokenPattern = /hf_[a-zA-Z0-9]{32,}/;
  if (tokenPattern.test(command)) {
    issues.push('Command contains hardcoded HuggingFace token');
  }
  
  return {
    valid: issues.length === 0,
    issues,
  };
}
