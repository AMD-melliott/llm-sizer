import type { ContainerConfig } from '../types';

export interface DockerComposeOptions {
  includeComments?: boolean;
  version?: string;
  enableHealthcheck?: boolean;
}

export function generateDockerCompose(
  config: ContainerConfig,
  options: DockerComposeOptions = {}
): string {
  const { includeComments = true, version = '3.8', enableHealthcheck = true } = options;
  
  const lines: string[] = [];
  
  // Version
  lines.push(`version: '${version}'`);
  lines.push('');
  
  // Services
  lines.push('services:');
  lines.push(`  ${config.containerName}:`);
  
  // Image
  lines.push(`    image: ${config.image.fullImage}`);
  
  // Container name
  lines.push(`    container_name: ${config.containerName}`);
  
  // Runtime
  if (config.useContainerToolkit) {
    lines.push('    runtime: amd');
  }
  
  // Environment
  if (config.environment.length > 0) {
    lines.push('    environment:');

    // Environment variables (GPU devices are already in config.environment)
    config.environment.forEach(env => {
      if (includeComments && env.description) {
        lines.push(`      # ${env.description}`);
      }
      lines.push(`      - ${env.key}=${env.value}`);
    });
  }
  
  // Devices (fallback method)
  if (!config.useContainerToolkit) {
    lines.push('    devices:');
    lines.push('      - /dev/kfd:/dev/kfd');
    lines.push('      - /dev/dri:/dev/dri');
    lines.push('    group_add:');
    lines.push('      - video');
  }
  
  // Shared memory
  lines.push(`    shm_size: ${config.shmSize}`);
  
  // Resource limits
  if (config.resourceLimits) {
    if (config.resourceLimits.memoryLimit || config.resourceLimits.cpuLimit) {
      lines.push('    deploy:');
      lines.push('      resources:');
      lines.push('        limits:');
      
      if (config.resourceLimits.cpuLimit) {
        lines.push(`          cpus: '${config.resourceLimits.cpuLimit}'`);
      }
      
      if (config.resourceLimits.memoryLimit) {
        lines.push(`          memory: ${config.resourceLimits.memoryLimit}`);
      }
    }
  }
  
  // Volumes
  if (config.volumes.length > 0) {
    lines.push('    volumes:');
    config.volumes.forEach(vol => {
      if (includeComments && vol.description) {
        lines.push(`      # ${vol.description}`);
      }
      const ro = vol.readOnly ? ':ro' : '';
      lines.push(`      - ${vol.hostPath}:${vol.containerPath}${ro}`);
    });
  }
  
  // Ports
  if (!config.useHostNetwork && config.ports.length > 0) {
    lines.push('    ports:');
    config.ports.forEach(port => {
      if (includeComments && port.description) {
        lines.push(`      # ${port.description}`);
      }
      const protocol = port.protocol ? `/${port.protocol}` : '';
      lines.push(`      - "${port.host}:${port.container}${protocol}"`);
    });
  }
  
  // Network mode
  if (config.useHostNetwork) {
    lines.push('    network_mode: host');
  }
  
  // Restart policy
  lines.push('    restart: unless-stopped');
  
  // Command (engine parameters)
  if (config.engineParams.length > 0) {
    lines.push('    command:');
    
    // Build command as array for better readability
    const commandParts: string[] = [];
    config.engineParams.forEach(param => {
      if (typeof param.value === 'boolean') {
        if (param.value) {
          commandParts.push(param.flag);
        }
      } else {
        commandParts.push(param.flag);
        commandParts.push(String(param.value));
      }
    });
    
    // Format as YAML array
    commandParts.forEach(part => {
      lines.push(`      - "${part}"`);
    });
  }
  
  // Health check (optional, configurable)
  if (enableHealthcheck) {
    const apiPort = config.ports.find(p => p.container === 8000)?.container || 8000;
    lines.push('    healthcheck:');
    lines.push(`      test: ["CMD-SHELL", "curl -f http://localhost:${apiPort}/health || wget -q --spider http://localhost:${apiPort}/health || exit 1"]`);
    lines.push('      interval: 30s');
    lines.push('      timeout: 10s');
    lines.push('      retries: 3');
    lines.push('      start_period: 60s');
  }
  
  // Comments at the end
  if (includeComments) {
    lines.push('');
    lines.push('# Generated by AMD LLM Sizer - Docker Configuration Generator');
    lines.push(`# Generated: ${new Date().toISOString()}`);
    lines.push(`# Model: ${config.model.name} (${config.model.parameters}B parameters)`);
    lines.push(`# GPUs: ${config.gpuCount}x ${config.gpus[0]?.name || 'GPU'}`);
    lines.push(`# Estimated VRAM: ${config.memoryUsage.estimated.toFixed(1)}GB / ${config.memoryUsage.available.toFixed(1)}GB (${config.memoryUsage.percentage.toFixed(1)}%)`);
    lines.push('#');
    lines.push('# Usage:');
    lines.push('#   docker-compose up -d        # Start in background');
    lines.push('#   docker-compose logs -f      # View logs');
    lines.push('#   docker-compose down         # Stop and remove');
    lines.push('#   docker-compose restart      # Restart service');
    lines.push('#');
    lines.push('# Prerequisites:');
    if (config.useContainerToolkit) {
      lines.push('#   - AMD Container Toolkit installed');
      lines.push('#   - https://rocm.docs.amd.com/projects/container-toolkit');
    }
    lines.push('#   - Docker Compose v2.0 or higher');
    if (config.environment.some(env => env.sensitive)) {
      lines.push('#   - Create .env file with sensitive variables (e.g., HF_TOKEN)');
    }
  }
  
  return lines.join('\n');
}

export function generateDotEnvTemplate(config: ContainerConfig): string {
  const lines: string[] = [];
  
  lines.push('# Environment variables for Docker Compose');
  lines.push(`# Generated: ${new Date().toISOString()}`);
  lines.push('#');
  lines.push('# Copy this file to .env and fill in the values');
  lines.push('#');
  
  config.environment
    .filter(env => env.sensitive)
    .forEach(env => {
      if (env.description) {
        lines.push(`# ${env.description}`);
      }
      lines.push(`${env.key}=`);
      lines.push('');
    });
  
  return lines.join('\n');
}

// Helper to validate Docker Compose YAML
export function validateDockerCompose(yaml: string): {
  valid: boolean;
  issues: string[];
} {
  const issues: string[] = [];
  
  // Check for security anti-patterns
  if (yaml.includes('privileged: true')) {
    issues.push('Compose file contains privileged mode (security risk)');
  }
  
  if (yaml.includes('cap_add:') && yaml.includes('SYS_ADMIN')) {
    issues.push('Compose file contains CAP_SYS_ADMIN capability (security risk)');
  }
  
  // Check for hardcoded secrets
  const tokenPattern = /hf_[a-zA-Z0-9]{32,}/;
  if (tokenPattern.test(yaml)) {
    issues.push('Compose file contains hardcoded HuggingFace token');
  }
  
  // Check for version
  if (!yaml.includes('version:')) {
    issues.push('Compose file missing version specification');
  }
  
  return {
    valid: issues.length === 0,
    issues,
  };
}
